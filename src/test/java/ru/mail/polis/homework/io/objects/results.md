# Результаты разных сериализаций
Тесты проводились при количестве генерируемых данных = 1000000
```
DEFAULT serialization/deserialization
	File size: 47701615 byte
	Write time: 9166 ms
	Read time: 12439 ms

WITH METHODS serialization/deserialization
	File size: 77047480 byte
	Write time: 15060 ms
	Read time: 16890 ms

EXTERNALIZABLE serialization/deserialization
	File size: 51709608 byte
	Write time: 11441 ms
	Read time: 10799 ms

CUSTOM serialization/deserialization
	File size: 37691789 byte
	Write time: 3143 ms
	Read time: 2557 ms
```

# Сравнение
Лучшим вариантом оказалась `CUSTOM serialization`. Неудивительно, ведь при кастомной реализации программист сам решает
что нужно будет сериализовывать (целый класс/половину класса/etc). При кастомной десериализации программист также 
напрямую указывает что конкретно нужно десериализовывать. Из-за этого получаются лучшее время чтения/записи
и самый маленький размер сгенерированного файла.

Разница между `DEFAULT serialization` и `EXTERNALIZABLE serialization` не очень велика, но очень сильно отличается 
от `CUSTOM serialization`. Это связано с тем, что при дефолтной реализации `JVM` использует `Reflection API` и сама
определяет типы полей в классе. На это требуется время, поэтому идет просадка по производительности. Размер файла больше
при дефолтной реализации, так как помимо полей класса в файл записываются дополнительные служебные данные.

`WITH METHODS serialization` имеет худшие показатели. Самое большое время чтения/записи связано с самым большим размером файла.
Самый большой размер файла связан, скорее всего, с отсутвием "оптимизации" записываемых данных со стороны JVM.

#Вывод
Лучше всего использовать кастомную сериализацию. Хоть она самая сложная в реализации, но зато в этом случае программист 
имеет полный контроль над сериализуемыми данными и способен сам регулировать, как размер файла, так и время чтения/записи.